import os
import re
import io
import zipfile
import tempfile
import pathlib
import streamlit as st
from pptx import Presentation
from pptx.enum.shapes import MSO_SHAPE_TYPE
from fpdf import FPDF

# DeepL ë¶ˆëŸ¬ì˜¤ê¸°
try:
    import deepl
except Exception:
    st.error("`deepl` íŒ¨í‚¤ì§€ê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. í„°ë¯¸ë„ì—ì„œ `pip install deepl` ì‹¤í–‰ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.")
    st.stop()

try:
    import fitz  # PyMuPDF
except Exception:
    st.error("`PyMuPDF` íŒ¨í‚¤ì§€ê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. í„°ë¯¸ë„ì—ì„œ `pip install pymupdf` ì‹¤í–‰ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.")
    st.stop()

# ì›ê²© í°íŠ¸ ë‹¤ìš´ë¡œë“œìš©
try:
    import requests
except Exception:
    st.error("`requests` íŒ¨í‚¤ì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤. í„°ë¯¸ë„ì—ì„œ `pip install requests` ì‹¤í–‰ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.")
    st.stop()

SUPPORTED_EXTS = {".pptx", ".pdf"}  # Free ìš”ê¸ˆì œ: PPTX + PDF ì§€ì›

# -----------------------------
# ì„¸ì…˜ ìƒíƒœ ì´ˆê¸°í™”
# -----------------------------
if "dl_results" not in st.session_state:
    st.session_state["dl_results"] = []   # [{label, code, path}]
if "work_ext" not in st.session_state:
    st.session_state["work_ext"] = None   # ".pptx" | ".pdf"
if "work_name" not in st.session_state:
    st.session_state["work_name"] = ""    # ì—…ë¡œë“œ ì›ë³¸ íŒŒì¼ëª…
if "saved_inputs" not in st.session_state:
    st.session_state["saved_inputs"] = {} # ì—…ë¡œë“œ ë¹„êµìš©

# -----------------------------
# ìœ í‹¸
# -----------------------------
def get_deepl_key():
    key_from_input = st.session_state.get("user_api_key")
    if key_from_input:
        return key_from_input
    return os.environ.get("DEEPL_API_KEY")

def save_uploaded_file(uploaded_file) -> pathlib.Path:
    suffix = pathlib.Path(uploaded_file.name).suffix.lower()
    with tempfile.NamedTemporaryFile(delete=False, suffix=suffix) as tmp:
        tmp.write(uploaded_file.read())
        return pathlib.Path(tmp.name)

def output_path_for(input_path: pathlib.Path, target_lang_code: str, new_ext: str | None = None) -> pathlib.Path:
    suffix = new_ext if new_ext else input_path.suffix
    return input_path.with_name(f"{input_path.stem}.translated_{target_lang_code}{suffix}")

def clear_results():
    # ì„ì‹œ ê²°ê³¼ íŒŒì¼ ì‚­ì œ
    for item in st.session_state["dl_results"]:
        try:
            pathlib.Path(item["path"]).unlink(missing_ok=True)
        except Exception:
            pass
    st.session_state["dl_results"] = []
    st.session_state["work_ext"] = None
    st.session_state["work_name"] = ""

def safe_rerun():
    # Streamlit ë²„ì „ í˜¸í™˜
    if hasattr(st, "rerun"):
        st.rerun()
    elif hasattr(st, "experimental_rerun"):
        st.experimental_rerun()

# -----------------------------
# í”Œë˜ê·¸ ì´ëª¨ì§€ & êµ­ê°€ì½”ë“œ ë§¤í•‘
# -----------------------------
FLAG_EMOJI = {
    "AR": "ğŸ‡¸ğŸ‡¦", "BG": "ğŸ‡§ğŸ‡¬", "CS": "ğŸ‡¨ğŸ‡¿", "DA": "ğŸ‡©ğŸ‡°", "DE": "ğŸ‡©ğŸ‡ª", "EL": "ğŸ‡¬ğŸ‡·",
    "EN": "ğŸ‡¬ğŸ‡§", "EN-GB": "ğŸ‡¬ğŸ‡§", "EN-US": "ğŸ‡ºğŸ‡¸", "ES": "ğŸ‡ªğŸ‡¸", "ES-419": "ğŸ‡²ğŸ‡½",
    "ET": "ğŸ‡ªğŸ‡ª", "FI": "ğŸ‡«ğŸ‡®", "FR": "ğŸ‡«ğŸ‡·", "HE": "ğŸ‡®ğŸ‡±", "HU": "ğŸ‡­ğŸ‡º", "ID": "ğŸ‡®ğŸ‡©",
    "IT": "ğŸ‡®ğŸ‡¹", "JA": "ğŸ‡¯ğŸ‡µ", "KO": "ğŸ‡°ğŸ‡·", "LT": "ğŸ‡±ğŸ‡¹", "LV": "ğŸ‡±ğŸ‡»", "NB": "ğŸ‡³ğŸ‡´",
    "NL": "ğŸ‡³ğŸ‡±", "PL": "ğŸ‡µğŸ‡±", "PT": "ğŸ‡µğŸ‡¹", "PT-BR": "ğŸ‡§ğŸ‡·", "PT-PT": "ğŸ‡µğŸ‡¹",
    "RO": "ğŸ‡·ğŸ‡´", "RU": "ğŸ‡·ğŸ‡º", "SK": "ğŸ‡¸ğŸ‡°", "SL": "ğŸ‡¸ğŸ‡®", "SV": "ğŸ‡¸ğŸ‡ª", "TH": "ğŸ‡¹ğŸ‡­",
    "TR": "ğŸ‡¹ğŸ‡·", "UK": "ğŸ‡ºğŸ‡¦", "VI": "ğŸ‡»ğŸ‡³", "ZH": "ğŸ‡¨ğŸ‡³", "ZH-HANS": "ğŸ‡¨ğŸ‡³", "ZH-HANT": "ğŸ‡¹ğŸ‡¼"
}
LANG_TO_CC = {
    "AR": "SA", "BG": "BG", "CS": "CZ", "DA": "DK", "DE": "DE", "EL": "GR",
    "EN": "GB", "EN-GB": "GB", "EN-US": "US", "ES": "ES", "ES-419": "MX",
    "ET": "EE", "FI": "FI", "FR": "FR", "HE": "IL", "HU": "HU", "ID": "ID",
    "IT": "IT", "JA": "JP", "KO": "KR", "LT": "LT", "LV": "LV", "NB": "NO",
    "NL": "NL", "PL": "PL", "PT": "PT", "PT-BR": "BR", "PT-PT": "PT",
    "RO": "RO", "RU": "RU", "SK": "SK", "SL": "SI", "SV": "SE", "TH": "TH",
    "TR": "TR", "UK": "UA", "VI": "VN", "ZH": "CN", "ZH-HANS": "CN", "ZH-HANT": "TW"
}
def build_label(name: str, code: str) -> str:
    code_up = code.upper()
    flag = FLAG_EMOJI.get(code_up, "ğŸŒ")
    cc = LANG_TO_CC.get(code_up, code_up.split("-")[0])
    return f"{flag} [{cc}] {name} â€“ {code_up}"

# -----------------------------
# DeepL íƒ€ê²Ÿ ì–¸ì–´ ë™ì  ë¡œë“œ (+ next-gen only ë³´ê°•)
# -----------------------------
@st.cache_data(show_spinner=False)
def fetch_target_languages(auth_key: str):
    translator = deepl.Translator(auth_key)
    langs = translator.get_target_languages()  # list[Language]
    pairs = {l.code.upper(): build_label(l.name, l.code) for l in langs}
    # ë¬¸ì„œ ê³µì§€ ê¸°ì¤€: /languagesì— ì—†ì„ ìˆ˜ ìˆëŠ” next-gen ì „ìš© íƒ€ê²Ÿ ì–¸ì–´ ë³´ê°•
    NEXT_GEN_ONLY = [
        ("HE", "Hebrew (next-gen only)"),
        ("TH", "Thai (next-gen only)"),
        ("VI", "Vietnamese (next-gen only)"),
        ("ES-419", "Spanish (Latin American, next-gen only)"),
    ]
    for code, name in NEXT_GEN_ONLY:
        pairs.setdefault(code, build_label(name, code))
    return sorted([(label, code) for code, label in pairs.items()], key=lambda x: x[0].lower())

# -----------------------------
# PPTX ë²ˆì—­ (ì›ë³¸ ìœ ì§€)
# -----------------------------
def translate_pptx_text(input_fp: pathlib.Path, output_fp: pathlib.Path, target_lang: str, translator: "deepl.Translator"):
    prs = Presentation(str(input_fp))
    num_prefix_re = re.compile(r'^\s*(\d+[\.\)]\s*)')

    def translate_batch(texts: list[str]) -> list[str]:
        if not texts:
            return []
        res = translator.translate_text(
            texts,
            target_lang=target_lang,
            preserve_formatting=True,
            split_sentences="nonewlines",
        )
        if isinstance(res, list):
            return [r.text for r in res]
        return [res.text]

    def iter_shapes(shapes):
        for shp in shapes:
            yield shp
            if shp.shape_type == MSO_SHAPE_TYPE.GROUP:
                yield from iter_shapes(shp.shapes)

    for slide in prs.slides:
        for shp in iter_shapes(slide.shapes):
            if shp.has_text_frame:
                paras = shp.text_frame.paragraphs
                items = []
                for p in paras:
                    raw = p.text
                    if raw and raw.strip():
                        m = num_prefix_re.match(raw)
                        prefix = m.group(0) if m else ""
                        core = raw[m.end():] if m else raw
                        items.append((p, prefix, core))

                translated = translate_batch([core for (_, _, core) in items])
                for (p, prefix, _), new_text in zip(items, translated):
                    if not p.runs:
                        continue
                    p.runs[0].text = prefix + new_text
                    for run in p.runs[1:]:
                        run.text = ""

            if shp.shape_type == MSO_SHAPE_TYPE.TABLE:
                for row in shp.table.rows:
                    for cell in row.cells:
                        paras = cell.text_frame.paragraphs
                        items = []
                        for p in paras:
                            raw = p.text
                            if raw and raw.strip():
                                m = num_prefix_re.match(raw)
                                prefix = m.group(0) if m else ""
                                core = raw[m.end():] if m else raw
                                items.append((p, prefix, core))

                        translated = translate_batch([core for (_, _, core) in items])
                        for (p, prefix, _), new_text in zip(items, translated):
                            if not p.runs:
                                continue
                            p.runs[0].text = prefix + new_text
                            for run in p.runs[1:]:
                                run.text = ""

    prs.save(str(output_fp))

# -----------------------------
# (êµì²´ë¨) PDF ë²ˆì—­ â€” ìœ ë‹ˆì½”ë“œ í°íŠ¸ ìë™ ë‹¤ìš´ë¡œë“œ + ì ìš©
# -----------------------------
# ì›ê²© í°íŠ¸ URL (ê³µì‹ Noto ì €ì¥ì†Œ)
FONT_URLS = {
    "NotoSans":     "https://raw.githubusercontent.com/notofonts/noto-fonts/main/hinted/ttf/NotoSans/NotoSans-Regular.ttf",
    "NotoSansThai": "https://raw.githubusercontent.com/notofonts/noto-fonts/main/hinted/ttf/NotoSansThai/NotoSansThai-Regular.ttf",
}

FONT_CACHE_DIR = pathlib.Path(tempfile.gettempdir()) / "translator_font_cache"
FONT_CACHE_DIR.mkdir(parents=True, exist_ok=True)

@st.cache_resource(show_spinner=False)
def ensure_font_local(name: str) -> pathlib.Path:
    """ì§€ì •í•œ í°íŠ¸ë¥¼ OS ì„ì‹œ ìºì‹œì— ë³´ê´€í•˜ê³  ê²½ë¡œë¥¼ ë°˜í™˜"""
    url = FONT_URLS.get(name)
    if not url:
        raise ValueError(f"Unknown font key: {name}")
    ext = ".ttf" if url.lower().endswith(".ttf") else ".otf"
    dest = FONT_CACHE_DIR / f"{name}{ext}"
    if dest.exists() and dest.stat().st_size > 0:
        return dest
    resp = requests.get(url, timeout=30)
    resp.raise_for_status()
    dest.write_bytes(resp.content)
    if dest.stat().st_size < 10_000:
        dest.unlink(missing_ok=True)
        raise RuntimeError(f"Font download failed (too small): {name}")
    return dest

def translate_pdf_text(input_fp: pathlib.Path, output_fp: pathlib.Path, target_lang: str, translator: "deepl.Translator"):
    doc = fitz.open(str(input_fp))
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)

    # 1) í•„ìš”í•œ í°íŠ¸ í™•ë³´ & ë“±ë¡ (ë¼í‹´/ë² íŠ¸ë‚¨ì–´ ë“±: NotoSans, íƒœêµ­ì–´: NotoSansThai)
    try:
        path_sans = ensure_font_local("NotoSans")
        pdf.add_font("NotoSans", "", str(path_sans), uni=True)
    except Exception as e:
        st.error(f"ê¸°ë³¸ í°íŠ¸ ë‹¤ìš´ë¡œë“œ/ë“±ë¡ ì‹¤íŒ¨: {e}")
        return

    path_thai = None
    try:
        path_thai = ensure_font_local("NotoSansThai")
        pdf.add_font("NotoThai", "", str(path_thai), uni=True)
    except Exception:
        # íƒœêµ­ì–´ê°€ ì•„ë‹ˆë©´ ì—†ì–´ë„ ì§„í–‰ ê°€ëŠ¥
        path_thai = None

    # 2) ê°„ë‹¨í•œ ìŠ¤í¬ë¦½íŠ¸ ê°ì§€ë¡œ í°íŠ¸ ì„ íƒ
    re_th = re.compile(r"[\u0E00-\u0E7F]")  # Thai block

    def pick_font(s: str) -> str:
        if path_thai and re_th.search(s):
            return "NotoThai"
        return "NotoSans"

    # 3) í˜ì´ì§€ë³„ ë²ˆì—­ ë° ì¶œë ¥
    for page in doc:
        src_text = page.get_text("text") or ""
        try:
            tr_text = translator.translate_text(src_text, target_lang=target_lang).text if src_text.strip() else "[ë¹ˆ í˜ì´ì§€]"
        except Exception as e:
            tr_text = f"[ë²ˆì—­ ì‹¤íŒ¨] {e}"

        pdf.add_page()
        pdf.set_font(pick_font(tr_text), size=12)
        # fpdf2ëŠ” ìœ ë‹ˆì½”ë“œ ì¶œë ¥ ê°€ëŠ¥. latin-1 ì—ëŸ¬ ë°©ì§€ë¨.
        pdf.multi_cell(0, 8, tr_text)

    pdf.output(str(output_fp))

# -----------------------------
# UI
# -----------------------------
st.set_page_config(page_title="ì™¸êµ­ì¸ ê·¼ë¡œì êµì¬ ë²ˆì—­ê¸°", page_icon="ğŸŒ", layout="centered")

# ì´ëª¨ì§€ í°íŠ¸ ìš°ì„  ì ìš©
st.markdown("""
<style>
html, body, [class^="css"]  {
  font-family: system-ui, -apple-system, "Segoe UI", "Apple Color Emoji", "Segoe UI Emoji",
               "Noto Color Emoji", "Helvetica", "Arial", sans-serif !important;
}
.stMultiSelect, .stSelectbox, .stTextInput {
  font-family: system-ui, -apple-system, "Segoe UI", "Apple Color Emoji", "Segoe UI Emoji",
               "Noto Color Emoji", "Helvetica", "Arial", sans-serif !important;
}
</style>
""", unsafe_allow_html=True)

st.title("ğŸŒ ì™¸êµ­ì¸ ê·¼ë¡œì êµì¬ ë²ˆì—­ê¸°")
st.caption("DeepL API ê¸°ë°˜ PPTX/PDF ë²ˆì—­ â€” ì—¬ëŸ¬ ì–¸ì–´ ë™ì‹œ ë²ˆì—­, êµ­ê¸° ì•„ì´ì½˜ í¬í•¨")

with st.sidebar:
    st.header("ì„¤ì •")
    st.text_input(
        "DeepL API í‚¤",
        value=os.environ.get("DEEPL_API_KEY", ""),
        type="password",
        key="user_api_key",
        help="í‚¤ë¥¼ ì…ë ¥í•˜ë©´ ì§€ì› ì–¸ì–´ë¥¼ ìë™ìœ¼ë¡œ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤."
    )

    if st.button("ì–¸ì–´ ëª©ë¡ ìƒˆë¡œê³ ì¹¨", help="ìºì‹œë¥¼ ì§€ìš°ê³  DeepLì—ì„œ ë‹¤ì‹œ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤."):
        st.cache_data.clear()

    auth_key = get_deepl_key()
    target_lang_pairs = []
    if auth_key:
        try:
            target_lang_pairs = fetch_target_languages(auth_key)  # [(label, code)]
        except Exception as e:
            st.error(f"ì§€ì› ì–¸ì–´ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}")

    options = [label for (label, _) in target_lang_pairs]

    # âœ… ê¸°ë³¸ ì„ íƒ ì œê±°: default=[]
    tgt_labels = st.multiselect(
        "ëª©í‘œ ì–¸ì–´ ì„ íƒ (ì—¬ëŸ¬ ê°œ ê°€ëŠ¥)",
        options,
        default=[],
        placeholder="API í‚¤ ì…ë ¥ í›„ ì„ íƒí•˜ì„¸ìš” (ê¸°ë³¸ ì„ íƒ ì—†ìŒ)",
        help="í”Œë˜ê·¸ê°€ ê¸€ìë¡œ ë³´ì¼ ê²½ìš°ì—ë„ [CC]ê°€ í•¨ê»˜ í‘œì‹œë©ë‹ˆë‹¤."
    )
    target_langs = [code for (lbl, code) in target_lang_pairs if lbl in tgt_labels]

# ì—…ë¡œë“œ ìœ„ì ¯ (ìƒˆ íŒŒì¼ ì„ íƒ ì‹œ ì´ì „ ê²°ê³¼ ì§€ì›€)
uploaded = st.file_uploader(
    "ë²ˆì—­í•  PPTX ë˜ëŠ” PDF íŒŒì¼ ì—…ë¡œë“œ",
    type=[ext[1:] for ext in SUPPORTED_EXTS],
    accept_multiple_files=False,
    help="Free ìš”ê¸ˆì œëŠ” PPTX + PDFë§Œ ì§€ì›í•©ë‹ˆë‹¤."
)
if uploaded:
    # ìƒˆ íŒŒì¼ë¡œ ë°”ë€Œì—ˆëŠ”ì§€ ì²´í¬
    cur_name = uploaded.name
    prev_name = st.session_state["saved_inputs"].get("uploaded_name")
    if prev_name != cur_name:
        clear_results()
        st.session_state["saved_inputs"]["uploaded_name"] = cur_name

start = st.button("ë²ˆì—­ ì‹œì‘", type="primary", disabled=not uploaded or not target_langs or not get_deepl_key())

# -----------------------------
# ë²ˆì—­ ì‹¤í–‰ (ê²°ê³¼ëŠ” ì„¸ì…˜ì— ì €ì¥)
# -----------------------------
if start and uploaded:
    ext = pathlib.Path(uploaded.name).suffix.lower()
    if ext not in SUPPORTED_EXTS:
        st.error(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” í™•ì¥ìì…ë‹ˆë‹¤: {ext}")
        st.stop()

    auth_key = get_deepl_key()
    if not auth_key:
        st.error("DeepL API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤.")
        st.stop()

    with st.spinner("ë²ˆì—­ ì¤‘ì…ë‹ˆë‹¤..."):
        in_path = save_uploaded_file(uploaded)
        out_ext = ".pptx" if ext == ".pptx" else ".pdf"
        translator = deepl.Translator(auth_key)

        # ì§„í–‰ë¥  ë°”
        progress = st.progress(0.0)
        total = max(len(target_langs), 1)

        label_by_code = {code: lbl for (lbl, code) in target_lang_pairs}
        made = []
        try:
            for i, lang_code in enumerate(target_langs, start=1):
                out_path = output_path_for(in_path, lang_code, new_ext=out_ext)
                if ext == ".pptx":
                    translate_pptx_text(in_path, out_path, lang_code, translator)
                else:
                    translate_pdf_text(in_path, out_path, lang_code, translator)
                made.append({"label": label_by_code.get(lang_code, lang_code),
                             "code": lang_code, "path": str(out_path)})
                progress.progress(i / total)
            # ì…ë ¥ ì„ì‹œ íŒŒì¼ì€ ì •ë¦¬
            try:
                in_path.unlink(missing_ok=True)
            except Exception:
                pass

            # âœ… ì„¸ì…˜ì— ì €ì¥í•˜ì—¬ ë¦¬ëŸ° í›„ì—ë„ ìœ ì§€
            st.session_state["dl_results"] = made
            st.session_state["work_ext"] = out_ext
            st.session_state["work_name"] = uploaded.name
            st.success("âœ… ë²ˆì—­ ì™„ë£Œ! ì•„ë˜ì—ì„œ íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•˜ì„¸ìš”.")
        except Exception as e:
            st.error(f"ë²ˆì—­ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

# -----------------------------
# ê²°ê³¼ ë‹¤ìš´ë¡œë“œ ì˜ì—­ (ì„¸ì…˜ ê¸°ë°˜ìœ¼ë¡œ í•­ìƒ ë Œë”)
# -----------------------------
if st.session_state["dl_results"]:
    ext = st.session_state["work_ext"]
    base = pathlib.Path(st.session_state["work_name"]).stem

    # ê°œë³„ ë‹¤ìš´ë¡œë“œ ë²„íŠ¼
    for idx, item in enumerate(st.session_state["dl_results"]):
        try:
            with open(item["path"], "rb") as f:
                mime = ("application/vnd.openxmlformats-officedocument.presentationml.presentation"
                        if ext == ".pptx" else "application/pdf")
                st.download_button(
                    label=f'{item["label"]} ë²ˆì—­ë³¸ ë‹¤ìš´ë¡œë“œ',
                    data=f.read(),
                    file_name=pathlib.Path(item["path"]).name,
                    mime=mime,
                    key=f"dl-{idx}"  # ğŸ”‘ ë¦¬ëŸ°ì—ë„ ê³ ìœ  í‚¤ ìœ ì§€
                )
        except FileNotFoundError:
            st.warning(f"íŒŒì¼ì´ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤: {item['path']}")

    # ZIP ë‹¤ìš´ë¡œë“œ (2ê°œ ì´ìƒì¼ ë•Œ)
    if len(st.session_state["dl_results"]) > 1:
        zip_buf = io.BytesIO()
        with zipfile.ZipFile(zip_buf, "w", zipfile.ZIP_DEFLATED) as zf:
            for item in st.session_state["dl_results"]:
                p = pathlib.Path(item["path"])
                if p.exists():
                    zf.write(p, arcname=p.name)
        zip_buf.seek(0)
        st.download_button(
            label=f"ëª¨ë“  ë²ˆì—­ë³¸ ZIPìœ¼ë¡œ ë‹¤ìš´ë¡œë“œ ({len(st.session_state['dl_results'])}ê°œ)",
            data=zip_buf.read(),
            file_name=f"{base}_translations.zip",
            mime="application/zip",
            key="zip-all"  # ğŸ”‘ ê³ ìœ  í‚¤
        )

    # ê²°ê³¼ ì§€ìš°ê¸°
    if st.button("ê²°ê³¼ ì§€ìš°ê¸°", key="clear-results", help="ê²°ê³¼ ë²„íŠ¼ì„ ìˆ¨ê¸°ê³  ì„ì‹œ íŒŒì¼ì„ ì‚­ì œí•©ë‹ˆë‹¤."):
        clear_results()
        safe_rerun()
